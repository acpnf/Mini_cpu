module cpu (
    input  wire        clk,
    input  wire        enviar,
    input  wire        ligar,        // usado como "clear" da saída
    input  wire [17:0] entrada,      // [17:15]=opcode, [14:11]=D1, [10:7]=r2, [6:3]=r3, [6:0]=imediato
    output reg  [15:0] saida,
    output reg         negativo      // indica se o número é negativo
);

    // Decodificação
    wire [2:0] opcode   = entrada[17:15];
    wire [3:0] D1       = entrada[14:11];
    wire [3:0] r2       = entrada[10:7];
    wire [3:0] r3       = entrada[6:3];
    wire [6:0] imediato = entrada[6:0];

    wire        flag_ram;
    wire [15:0] resultado;
    wire        resultado_neg;

    // Função de conversão: complemento de dois -> sinal+magnitude (16 bits)
    function [15:0] to_signmag(input signed [15:0] val);
        if (val < 0)
            to_signmag = {1'b1, -val[14:0]}; // bit 15 = sinal, magnitude absoluta em 15 bits
        else
            to_signmag = {1'b0, val[14:0]};  // bit 15 = 0, magnitude em 15 bits
    endfunction

    // Latch simples da saída quando a memória confirmar
    always @(posedge clk) begin
        if (!ligar) begin
            saida    <= 16'h0000;
            negativo <= 1'b0;
        end
        else if (flag_ram) begin
            saida    <= to_signmag(resultado);   // conversão só na saída pros LEDs
            negativo <= resultado_neg;           // negativo fornecido pela memória
        end
    end

    // Instancia memória
    memoria u_mem (
        .opcode(opcode),
        .clk(clk),
        .enviar(enviar),
        .r2(r2),
        .r3(r3),
        .D1(D1),
        .imediato(imediato),
        .flag_ram(flag_ram),
        .saida(resultado),
        .negativo(resultado_neg)
    );

endmodule

///////////////////////////////////////////

module memoria (
    input  wire [2:0] opcode,
    input  wire       clk,
    input  wire       enviar,      // pulso de start (detectamos a borda)
    input  wire [3:0] r2,
    input  wire [3:0] r3,
    input  wire [3:0] D1,
    input  wire [6:0] imediato,

    output reg        flag_ram,    // 1 ciclo quando terminar
    output reg [15:0] saida,
    output reg        negativo     // indica se o resultado é negativo
);

    // Memória de 16 x 16
    reg [15:0] ram [0:15];

    // Edge detector de 'enviar'
    reg enviar_d = 1'b0;
    always @(posedge clk) enviar_d <= enviar;
    wire start = enviar & ~enviar_d;

    // Latches dos operandos/controle (para pipeline simples)
    reg [2:0]  op_reg;
    reg [3:0]  D1_reg;
    reg [15:0] r2_val_reg, r3_val_reg;
    reg [6:0]  imm_reg;
    reg [15:0] result_reg;

    // FSM
    localparam IDLE = 2'd0,
               EXEC = 2'd1,
               WRITE= 2'd2;
    reg [1:0] st = IDLE;

    // ULA combinacional (com operandos latched)
    wire [15:0] alu_out;
    operacoes u_alu (
        .opcode(op_reg),
        .r2(r2_val_reg),
        .r3(r3_val_reg),
        .imediato(imm_reg),
        .result(alu_out)
    );

    always @(posedge clk) begin
        case (st)
            IDLE: begin
                flag_ram <= 1'b0;
                negativo <= 1'b0;

                // Reset do banco (opcode 110) somente quando der start
                if (start && opcode == 3'b110) begin
                    ram[0]  <= 16'h0000;
                    ram[1]  <= 16'h0000;
                    ram[2]  <= 16'h0000;
                    ram[3]  <= 16'h0000;
                    ram[4]  <= 16'h0000;
                    ram[5]  <= 16'h0000;
                    ram[6]  <= 16'h0000;
                    ram[7]  <= 16'h0000;
                    ram[8]  <= 16'h0000;
                    ram[9]  <= 16'h0000;
                    ram[10] <= 16'h0000;
                    ram[11] <= 16'h0000;
                    ram[12] <= 16'h0000;
                    ram[13] <= 16'h0000;
                    ram[14] <= 16'h0000;
                    ram[15] <= 16'h0000;
                    saida   <= 16'h0000;
                    flag_ram<= 1'b1; // confirma reset
                end
                else if (start) begin
                    // Latch de tudo e vai executar
                    op_reg      <= opcode;
                    D1_reg      <= D1;
                    r2_val_reg  <= ram[r2];
                    r3_val_reg  <= ram[r3];
                    imm_reg     <= imediato;
                    st          <= EXEC;
                end
            end

            EXEC: begin
                // Captura resultado estável da ULA
                if (op_reg == 3'b111) begin
                    // DPL: apenas mostra o valor do registrador r2
                    result_reg <= r2_val_reg;
                end
                else begin
                    result_reg <= alu_out;
                end
                st <= WRITE;
            end

            WRITE: begin
                // Grava somente se não for DPL (r2 apenas mostrado)
                if (op_reg != 3'b111) begin
                    ram[D1_reg] <= result_reg;
                end
                saida       <= result_reg;
                negativo    <= result_reg[15];  // MSB indica sinal
                flag_ram    <= 1'b1;            // pulso de 1 ciclo
                st          <= IDLE;
            end

            default: st <= IDLE;
        endcase
    end

endmodule

////////////////////////////////////////

module operacoes (
    input  wire [2:0]  opcode,
    input  wire [15:0] r2,
    input  wire [15:0] r3,
    input  wire [6:0]  imediato,
    output reg  [15:0] result
);
    // OpCodes
    localparam load = 3'b000,
               add  = 3'b001,
               addi = 3'b010,
               sub  = 3'b011,
               subi = 3'b100,
               mul  = 3'b101;

    // Converte imediato de sinal+magnitude (7 bits) -> complemento de dois (16 bits)
    wire signed [15:0] imm = (imediato[6]) ?
                             -$signed({10'b0, imediato[5:0]}) : // negativo
                              $signed({10'b0, imediato[5:0]}); // positivo

    // Versões com sinal (complemento de dois) dos registradores
    wire signed [15:0] r2s = $signed(r2);
    wire signed [15:0] r3s = $signed(r3);

    always @* begin
        case (opcode)
            load: result = imm;
            add : result = r2s + r3s;
            addi: result = r2s + imm;
            sub : result = r2s - r3s;
            subi: result = r2s - imm;
            mul : result = r2s * imm;      // truncado para 16 bits
            default: result = 16'h0000;
        endcase
    end
endmodule
