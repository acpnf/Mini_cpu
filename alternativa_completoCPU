module cpu (
    input  wire        clk,
    input  wire        enviar,
    input  wire        ligar,        // usado como "clear" da saída
    input  wire [17:0] entrada,      // [17:15]=opcode, [14:11]=D1, [10:7]=r2, [6:0]=imediato
    output reg  [15:0] saida,        // saída em sinal+magnitude
    output reg         neg_flag      // LED indicador de número negativo
);

    // Decodificação
    wire [2:0] opcode   = entrada[17:15];
    wire [3:0] D1       = entrada[14:11];
    wire [3:0] r2       = entrada[10:7];
    wire [3:0] r3       = entrada[6:3];
    wire [6:0] imediato = entrada[6:0];

    wire        flag_ram;
    wire [15:0] resultado;

    // Função de conversão: complemento de dois -> sinal+magnitude (16 bits)
    function [15:0] to_signmag(input signed [15:0] val);
        reg [15:0] mag;
        begin
            if (val < 0) begin
                mag = -val;                  // magnitude absoluta
                to_signmag = {1'b1, mag[14:0]}; // bit 15 = sinal
            end
            else begin
                to_signmag = {1'b0, val[14:0]};
            end
        end
    endfunction

    // Latch simples da saída quando a memória confirmar
    always @(posedge clk) begin
        if (!ligar) begin
            saida    <= 16'h0000;
            neg_flag <= 1'b0;
        end
        else if (flag_ram) begin
            saida    <= to_signmag($signed(resultado));
            neg_flag <= to_signmag($signed(resultado))[15];
        end
    end

    // Instancia memória
    memoria u_mem (
        .opcode(opcode),
        .clk(clk),
        .enviar(enviar),
        .r2(r2),
        .r3(r3),
        .D1(D1),
        .imediato(imediato),
        .flag_ram(flag_ram),
        .saida(resultado)
    );

endmodule

///////////////////////////////////////////////////////

module memoria (
    input  wire [2:0] opcode,
    input  wire       clk,
    input  wire       enviar,
    input  wire [3:0] r2,
    input  wire [3:0] r3,
    input  wire [3:0] D1,
    input  wire [6:0] imediato,

    output reg        flag_ram,
    output reg [15:0] saida
);

    reg [15:0] ram [0:15];

    reg enviar_d = 1'b0;
    always @(posedge clk) enviar_d <= enviar;
    wire start = enviar & ~enviar_d;

    reg [2:0]  op_reg;
    reg [3:0]  D1_reg;
    reg [15:0] r2_val_reg, r3_val_reg;
    reg [6:0]  imm_reg;
    reg [15:0] result_reg;

    localparam IDLE = 2'd0,
               EXEC = 2'd1,
               WRITE= 2'd2;
    reg [1:0] st = IDLE;

    wire [15:0] alu_out;
    operacoes u_alu (
        .opcode(op_reg),
        .r2(r2_val_reg),
        .r3(r3_val_reg),
        .imediato(imm_reg),
        .result(alu_out)
    );

    always @(posedge clk) begin
        case (st)
            IDLE: begin
                flag_ram <= 1'b0;
                if (start && opcode == 3'b110) begin
                    // Reset RAM
                    integer i;
                    for (i=0;i<16;i=i+1) ram[i] <= 16'h0000;
                    saida    <= 16'h0000;
                    flag_ram <= 1'b1;
                end
                else if (start) begin
                    op_reg      <= opcode;
                    D1_reg      <= D1;
                    r2_val_reg  <= ram[r2];
                    r3_val_reg  <= ram[r3];
                    imm_reg     <= imediato;
                    st          <= EXEC;
                end
            end

            EXEC: begin
                result_reg <= alu_out;
                st         <= WRITE;
            end

            WRITE: begin
                ram[D1_reg] <= result_reg;
                saida       <= result_reg;
                flag_ram    <= 1'b1;
                st          <= IDLE;
            end

            default: st <= IDLE;
        endcase
    end

endmodule

///////////////////////////////////////////////////////

module operacoes (
    input  wire [2:0]  opcode,
    input  wire [15:0] r2,
    input  wire [15:0] r3,
    input  wire [6:0]  imediato,
    output reg  [15:0] result
);

    localparam load = 3'b000,
               add  = 3'b001,
               addi = 3'b010,
               sub  = 3'b011,
               subi = 3'b100,
               mul  = 3'b101,
                dlp  = 3'b111;

    wire signed [15:0] r2s = $signed(r2);
    wire signed [15:0] r3s = $signed(r3);
    wire signed [15:0] imm_s = {{9{imediato[6]}}, imediato}; // extensão de sinal 7->16 bits

    always @* begin
        case (opcode)
            load : result = imm_s;
            add  : result = r2s + r3s;
            addi : result = r2s + imm_s;
            sub  : result = r2s - r3s;   // operação signed
            subi : result = r2s - imm_s; // operação signed
            mul  : result = r2s * imm_s;
            dlp : result = r2s;
            default: result = 16'h0000;
        endcase
    end
endmodule
