module memoria (
    input wire [2:0] opcode,
    input  wire        clk,     // Clock do sistema
    input  wire        enviar, // botao para enviar
    input wire [3:0] r2,    // Write Enable (1 = escrita)
    input wire [3:0] r3,
    input  wire [3:0]  D1,    // Endereço (4 bits = 16 registradores)
    input  wire [6:0] entrada,    // Imediato
    output reg [15:0] saida        // Dado de saída (16 bits)
);

    // declaracao da memoria RAM
    reg [15:0] ram [15:0];

    // registrador para armazenar o endereço de leitura
    reg [3:0] D1_reg;
    wire [15:0] dado_R1; //valor que será recebido em R1
    wire [15:0] dado_R2;
    wire [15:0] dado_R3;
    reg [15:0] resultado;
    reg [15:0] clear [15:0];

    
    reg[1:0] estado_atual; 
    reg[1:0] prox_estado; 
    parameter INIT = 0, WAIT = 1, WRITE = 2;

    parameter load = 3'b000,
           add  = 3'b001,
           addi = 3'b010,
           sub  = 3'b011,
           subi = 3'b100,
           mul  = 3'b101;

    // Extensão de sinal do imediato (7 -> 16)
    wire signed [15:0] imm = {{9{entrada[6]}}, entrada};

    // Versões com sinal de r2/r3
    wire signed [15:0] r2s = $signed(r2);
    wire signed [15:0] r3s = $signed(r3);

    // ALU combinacional
    reg  signed [15:0] alu;

    //inicializacao da memoria
    initial begin 
        ram[0] <= 16'h0000;
        ram[1] <= 16'h0000;
        ram[2] <= 16'h0000;
        ram[3] <= 16'h0000;
        ram[4] <= 16'h0000;
        ram[5] <= 16'h0000;
        ram[6] <= 16'h0000;
        ram[7] <= 16'h0000;
        ram[8] <= 16'h0000;
        ram[9] <= 16'h0000;
        ram[10] <= 16'h0000;
        ram[11] <= 16'h0000;
        ram[12] <= 16'h0000;
        ram[13] <= 16'h0000;
        ram[14] <= 16'h0000;
        ram[15] <= 16'h0000;
        estado_atual <= WAIT;
    end

    always @(*) begin
        prox_estado = estado_atual;
        case(estado_atual)
            INIT: begin
                clear[0]  = 16'h0000;
                clear[1]  = 16'h0000;
                clear[2]  = 16'h0000;
                clear[3]  = 16'h0000;
                clear[4]  = 16'h0000;
                clear[5]  = 16'h0000;
                clear[6]  = 16'h0000;
                clear[7]  = 16'h0000;
                clear[8]  = 16'h0000;
                clear[9]  = 16'h0000;
                clear[10] = 16'h0000;
                clear[11] = 16'h0000;
                clear[12] = 16'h0000;
                clear[13] = 16'h0000;
                clear[14] = 16'h0000;
                clear[15] = 16'h0000;
                prox_estado = WAIT;
            end

            WAIT: begin
                if (enviar) begin
                    if (opcode == 3'b110) prox_estado = INIT;
                    else prox_estado = WRITE;
                end
            end    

            WRITE: begin
                case (opcode)
                    load: resultado= imm;
                    add : resultado = r2s + r3s;
                    addi: resultado = r2s + imm;
                    sub : resultado = r2s - r3s;
                    subi: resultado = r2s - imm;
                    mul : resultado = r2s * r3s; // truncado em 16 bits
                    default: resultado = 16'h0000;
                endcase
                prox_estado = WAIT;
            end
        endcase
    end


    always @(posedge clk) begin
        case(estado_atual)
            INIT: begin
                ram[0]  <= clear[0];
                ram[1]  <= clear[1];
                ram[2]  <= clear[2];
                ram[3]  <= clear[3];
                ram[4]  <= clear[4];
                ram[5]  <= clear[5];
                ram[6]  <= clear[6];
                ram[7]  <= clear[7];
                ram[8]  <= clear[8];
                ram[9]  <= clear[9];
                ram[10] <= clear[10];
                ram[11] <= clear[11];
                ram[12] <= clear[12];
                ram[13] <= clear[13];
                ram[14] <= clear[14];
                ram[15] <= clear[15];
                estado_atual <= WAIT;
            end

            WAIT: begin
                if (prox_estado == INIT) estado_atual <= prox_estado;
                else if (prox_estado == WRITE) estado_atual <= prox_estado;            
            end

            WRITE: begin
                saida <= resultado;
                estado_atual <= WAIT; 
            end
        endcase
    end

endmodule
