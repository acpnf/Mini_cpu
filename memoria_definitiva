module memoria (
    input  wire [2:0] opcode,
    input  wire       clk,
    input  wire       enviar,      // pulso de start (detectamos a borda)
    input  wire [3:0] r2,
    input  wire [3:0] r3,
    input  wire [3:0] D1,
    input  wire [6:0] imediato,

    output reg        flag_ram,    // 1 ciclo quando terminar
    output reg [15:0] saida,
    output reg        negativo     // indica se o resultado é negativo
);

    // Memória de 16 x 16
    reg [15:0] ram [0:15];

    // Edge detector de 'enviar'
    reg enviar_d = 1'b0;
    always @(posedge clk) enviar_d <= enviar;
    wire start = enviar & ~enviar_d;

    // Latches dos operandos/controle (para pipeline simples)
    reg [2:0]  op_reg;
    reg [3:0]  D1_reg;
    reg [15:0] r2_val_reg, r3_val_reg;
    reg [6:0]  imm_reg;
    reg [15:0] result_reg;

    // FSM
    localparam IDLE = 2'd0,
               EXEC = 2'd1,
               WRITE= 2'd2;
    reg [1:0] st = IDLE;

    // ULA combinacional (com operandos latched)
    wire [15:0] alu_out;
    operacoes u_alu (
        .opcode(op_reg),
        .r2(r2_val_reg),
        .r3(r3_val_reg),
        .imediato(imm_reg),
        .result(alu_out)
    );

    always @(posedge clk) begin
        case (st)
            IDLE: begin
                flag_ram <= 1'b0;
                negativo <= 1'b0;

                // Reset do banco (opcode 110) somente quando der start
                if (start && opcode == 3'b110) begin
                    ram[0]  <= 16'h0000;
                    ram[1]  <= 16'h0000;
                    ram[2]  <= 16'h0000;
                    ram[3]  <= 16'h0000;
                    ram[4]  <= 16'h0000;
                    ram[5]  <= 16'h0000;
                    ram[6]  <= 16'h0000;
                    ram[7]  <= 16'h0000;
                    ram[8]  <= 16'h0000;
                    ram[9]  <= 16'h0000;
                    ram[10] <= 16'h0000;
                    ram[11] <= 16'h0000;
                    ram[12] <= 16'h0000;
                    ram[13] <= 16'h0000;
                    ram[14] <= 16'h0000;
                    ram[15] <= 16'h0000;
                    saida   <= 16'h0000;
                    flag_ram<= 1'b1; // confirma reset
                end
                else if (start) begin
                    // Latch de tudo e vai executar
                    op_reg      <= opcode;
                    D1_reg      <= D1;
                    r2_val_reg  <= ram[r2];
                    r3_val_reg  <= ram[r3];
                    imm_reg     <= imediato;
                    st          <= EXEC;
                end
            end

            EXEC: begin
                // Captura resultado estável da ULA
                if (op_reg == 3'b111) begin
                    // DPL: apenas mostra o valor do registrador r2
                    result_reg <= r2_val_reg;
                end
                else begin
                    result_reg <= alu_out;
                end
                st <= WRITE;
            end

            WRITE: begin
                // Grava somente se não for DPL (r2 apenas mostrado)
                if (op_reg != 3'b111) begin
                    ram[D1_reg] <= result_reg;
                end
                saida       <= result_reg;
                negativo    <= result_reg[15];  // MSB indica sinal
                flag_ram    <= 1'b1;            // pulso de 1 ciclo
                st          <= IDLE;
            end

            default: st <= IDLE;
        endcase
    end

endmodule
